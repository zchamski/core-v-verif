(VInstr_realign
p0
ccopy_reg
_reconstructor
p1
(cvp_pack
Ip
p2
c__builtin__
object
p3
Ntp4
Rp5
(dp6
Vprop_count
p7
I2
sVname
p8
g0
sVprop_list
p9
(dp10
sVip_num
p11
I7
sVwid_order
p12
I7
sVrfu_dict
p13
(dp14
sVrfu_list
p15
(lp16
(V000_C extension
p17
g1
(cvp_pack
Prop
p18
g3
Ntp19
Rp20
(dp21
Vitem_count
p22
I1
sg8
g17
sVtag
p23
VVP_IP007_P000
p24
sVitem_list
p25
(dp26
sg12
I0
sg15
(lp27
(V000
p28
g1
(cvp_pack
Item
p29
g3
Ntp30
Rp31
(dp32
g8
V000
p33
sg23
VVP_FRONTEND_F007_S000_I000
p34
sVdescription
p35
VThe 32-bit aligned block coming from the CACHE sub-system enters the instr_realign module. This module extracts the instructions from the 32-bit blocks, up to two instructions because it is possible to fetch two instructions when C extension is used. If the instructions are not compressed, it is possible that the instruction is not aligned on the block size but rather interleaved with two cache blocks. In that case, two cache accesses are needed. The instr_realign module provides at maximum one instruction per cycle. Not complete instruction is stored in instr_realign module before being provided in the next cycles.
p36
sVpurpose
p37
VFRONTEND sub-system/Architecture and Modules/Instr_realign
p38
sVverif_goals
p39
VExecute program compiled with C extension. Cover the case when 2 instructions are fetched in the same cache block and when an instruction is interleaved with two cache block\u000a\u000a[NO NEED TO VERIFY THIS CASE]
p40
sVcoverage_loc
p41
V
p42
sVpfc
p43
I-1
sVtest_type
p44
I-1
sVcov_method
p45
I-1
sVcores
p46
I0
sVcomments
p47
g42
sVstatus
p48
g42
sVsimu_target_list
p49
(lp50
sg15
(lp51
sVrfu_list_2
p52
(lp53
sg13
(dp54
Vlock_status
p55
I0
ssbtp56
asVrfu_list_1
p57
(lp58
sg52
(lp59
sg13
(dp60
sbtp61
a(V001_Flush
p62
g1
(g18
g3
Ntp63
Rp64
(dp65
g22
I1
sg8
g62
sg23
VVP_IP007_P001
p66
sg25
(dp67
sg12
I1
sg15
(lp68
(V000
p69
g1
(g29
g3
Ntp70
Rp71
(dp72
g8
V000
p73
sg23
VVP_FRONTEND_F007_S001_I000
p74
sg35
VIn case of mispredict, flush, replay or branch predict, the instr_realign is re-initialized, the internal register storing the instruction alignment state is reset.
p75
sg37
VFRONTEND sub-system/Architecture and Modules/Instr_realign
p76
sg39
V[NO NEED TO VERIFY THIS CASE]
p77
sg41
g42
sg43
I-1
sg44
I-1
sg45
I-1
sg46
I0
sg47
g42
sg48
g42
sg49
(lp78
sg15
(lp79
sg52
(lp80
sg13
(dp81
g55
I0
ssbtp82
asg57
(lp83
sg52
(lp84
sg13
(dp85
sbtp86
asVrfu_list_0
p87
(lp88
sg57
(lp89
sVvptool_gitrev
p90
V$Id: af214b54d38e440023a14011aefff4dabfd5f5ad $
p91
sVio_fmt_gitrev
p92
V$Id: 052d0c6f3d12d7984d208b14555a56b2f0c2485d $
p93
sVconfig_gitrev
p94
V$Id: 0422e19126dae20ffc4d5a84e4ce3de0b6eb4eb5 $
p95
sVymlcfg_gitrev
p96
V$Id: 286c689bd48b7a58f9a37754267895cffef1270c $
p97
sbtp98
.